{
    "docs": [
        {
            "location": "/",
            "text": "LD4PE Linked Data Competency Index\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Overview"
        },
        {
            "location": "/#ld4pe-linked-data-competency-index",
            "text": "",
            "title": "LD4PE Linked Data Competency Index"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/D2695955/",
            "text": "LD4PE Competency Index\n\n\nVersion: 2017-06-22 15:43:48 \n\nRaw file: https://github.com... \n\nView at: https://ld4pe.github.com... \n\n\n\n\n[A] Topic Cluster\n\n\n[B] Topic\n\n\n\n\n[C] Competency: Tweet-length assertion of knowledge, skill, or habit of mind.\n\n\n[D] Benchmark: Action demonstrating accomplishment in related competencies.\n\n\n\n\n\n\n[A]\n Fundamentals of Resource Description Framework\n\n\n[B]\n Identity in RDF\n\n\n\n\n[C]\n Knows that anything can be named with Uniform Resource Identifiers (URIs), such as agents, places, events, artifacts, and concepts.\n\n\n[C]\n Understands that a \"real-world\" thing may need to be named with a URI distinct from the URI for information about that thing.\n\n\n[C]\n Recognizes that URIs are \"owned\" by the owners of their respective Internet domains.\n\n\n[C]\n Knows that Uniform Resource Identifiers, or URIs (1994), include Uniform Resource Locators (URLs, which locate web pages) as well as location-independent identifiers for physical, conceptual, or web resources.\n\n\n\n\n[B]\n RDF data model\n\n\n\n\n[C]\n Knows the subject-predicate-object component structure of a triple.\n\n\n[C]\n Understands the difference between literals and non-literal resources.\n\n\n[C]\n Understands that URIs and literals denote things in the world (\"resources\") real, imagined, or conceptual.\n\n\n[C]\n Understands that resources are declared to be members (instances) of classes using the property rdf:type.\n\n\n[C]\n Understands the use of datatypes and language tags with literals.\n\n\n[C]\n Understands blank nodes and their uses.\n\n\n[C]\n Understands that QNames define shorthand prefixes for long URIs.\n\n\n[D]\n Uses prefixes for URIs in RDF specifications and data.\n\n\n[C]\n Articulates differences between the RDF abstract data model and the XML and relational models.\n\n\n[C]\n Understands the RDF abstract data model as a directed labeled graph.\n\n\n[C]\n Knows graphic conventions for depicting RDF-based models.\n\n\n[D]\n Can use graphing or modeling software to share those models with others.\n\n\n[C]\n Understands a named graph as one of the collection of graphs comprising an RDF dataset, with a graph name unique in the context of that dataset.\n\n\n[C]\n Understands how a namespace, informally used in the RDF context for a namespace URI or RDF vocabulary, fundamentally differs from the namespace of data attributes and functions (methods) defined for an object-oriented class.\n\n\n\n\n[B]\n Related data models\n\n\n\n\n[C]\n Grasps essential differences between schemas for syntactic validation (e.g., XML) and for inferencing (RDF Schema).\n\n\n[C]\n Differentiates hierarchical document models (eg, XML) and graph models (RDF).\n\n\n[C]\n Understands how an RDF class (named set of things) fundamentally differs from an object-oriented programming class, which defines a type of object bundling \"state\" (attributes with data values) and \"behavior\" (functions that operate on state).\n\n\n\n\n[B]\n RDF serialization\n\n\n\n\n[C]\n Understands RDF serializations as interchangeable encodings of a given set of triples (RDF graph).\n\n\n[D]\n Uses tools to convert RDF data between different serializations.\n\n\n[C]\n Distinguishes the RDF abstract data model and concrete serializations of RDF data.\n\n\n[D]\n Expresses data in serializations such as RDF/XML, N-Triples, Turtle, N3, Trig, JSON-LD, and RDFa.\n\n\n\n\n\n\n[A]\n Fundamentals of Linked Data\n\n\n[B]\n Web technology\n\n\n\n\n[C]\n Knows the origins of the World Wide Web (1989) as a non-linear interactive system, or hypermedia, built on the Internet.\n\n\n[C]\n Understands that Linked Data (2006) extended the notion of a web of documents (the Web) to a notion of a web of finer-grained data (the Linked Data cloud).\n\n\n[C]\n Knows HyperText Markup Language, or HTML (1991+), as a language for \"marking up\" the content and multimedia components of Web pages.\n\n\n[C]\n Knows HTML5 (2014) as a version of HTML extended with support for complex web and mobile applications.\n\n\n[C]\n Knows Hypertext Transfer Protocol, or HTTP (1991+), as the basic technology for resolving hyperlinks and transferring data on the World Wide Web.\n\n\n[C]\n Knows Representational State Transfer, or REST (2000) as a software architectural style whereby browsers can exchange data with web servers, typically on the basis of well-known HTTP actions.\n\n\n\n\n[B]\n Linked Data principles\n\n\n\n\n[C]\n Knows Tim Berners-Lee's principles of Linked Data: use URIs to name things, use HTTP URIs that can be resolved to useful information, and create links to URIs of other things.\n\n\n[C]\n Knows the \"five stars\" of Open Data: put data on the Web, preferably in a structured and preferably non-proprietary format, using URIs to name things, and link to other data.\n\n\n\n\n[B]\n Linked Data policies and best practices\n\n\n\n\n[C]\n Knows the primary organizations related to Linked Data standardization.\n\n\n[D]\n Participates in developing standards and best practice with relevant organizations such as W3C.\n\n\n\n\n[B]\n Non-RDF linked data\n\n\n\n\n[A]\n RDF vocabularies and application profiles\n\n\n[B]\n Finding RDF-based vocabularies\n\n\n\n\n[D]\n [MOVE]Knows portals and registries for finding RDF-based vocabularies.\n\n\n[D]\n Finds properties and classes in the Linked Open Vocabularies (LOV) observatory and explores their versions and dependencies.\n\n\n\n\n[B]\n Designing RDF-based vocabularies\n\n\n\n\n[C]\n Uses RDF Schema to express semantic relationships within a vocabulary.\n\n\n[D]\n Correctly uses sub-class relationships in support of inference.\n\n\n[D]\n Correctly uses sub-property relationships in support of inference.\n\n\n[C]\n Reuses published properties and classes where available.\n\n\n[C]\n Coins namespace URIs, as needed, for any new properties and classes required.\n\n\n[D]\n Drafts a policy for coining URIs for properties and classes.\n\n\n[D]\n Chooses \"hash\"- or \"slash\"-based URI patterns based on requirements.\n\n\n[C]\n Knows Web Ontology Language, or OWL (2004), as a RDF vocabulary of properties and classes that extend support for expressive data modeling and automated inferencing (reasoning).\n\n\n[C]\n Knows that the word \"ontology\" is ambiguous, referring to any RDF vocabulary, but more typically a set of OWL classes and properties designed to support inferencing in a specific domain.\n\n\n[C]\n Knows Simple Knowledge Organization System, or SKOS (2009), an RDF vocabulary for expressing concepts that are labeled in natural languages, organized into informal hierarchies, and aggregated into concept schemes.\n\n\n[C]\n Knows SKOS eXtension for Labels, or SKOS-XL (2009), a small set of additional properties for describing and linking lexical labels as instances of the class Label.\n\n\n[C]\n Understands that in a formal sense, a SKOS concept is not an RDF class but an instance and, as such, is not formally associated with a set of instances (\"class extension\").\n\n\n[C]\n Understands that SKOS can express a flexibly associative structure of concepts without enabling the more rigid and automatic inferences typically specified in a class-based OWL ontology.\n\n\n[C]\n Understands that in contrast to OWL sub-class chains, hierarchies of SKOS concepts are designed not to form transitive chains automatically because this is not how humans think or organize information.\n\n\n[C]\n Knows the naming conventions for RDF properties and classes.\n\n\n\n\n[B]\n Maintaining RDF vocabularies\n\n\n\n\n[C]\n Understands policy options for persistence guarantees.\n\n\n[D]\n Can draft a persistence policy.\n\n\n\n\n[B]\n Versioning RDF vocabularies\n\n\n\n\n[C]\n Knows technical options for the form, content, and granularity of versions.\n\n\n[C]\n Understands the trade-offs between publishing RDF vocabularies in periodic, numbered releases versus more continual or incremental approaches.\n\n\n[D]\n Can express and justify a versioning policy.\n\n\n\n\n[B]\n Publishing RDF vocabularies\n\n\n\n\n[C]\n Understands the typical publication formats for RDF vocabularies and their relative advantages\n\n\n[C]\n Understands the purpose of publishing RDF vocabularies in multiple formats using content negotiation.\n\n\n[C]\n Understands that to be \"dereferencable\", a URI should be usable to retrieve a representation of the resource it identifies.\n\n\n[D]\n Ensures that when dereferenced by a Web browser, a URI returns a representation of the resource in human-readable HTML.\n\n\n[D]\n Ensures that when dereferenced by an RDF application, a URI returns representation of the resource in the requested RDF serialization syntax.\n\n\n\n\n[B]\n Mapping RDF vocabularies\n\n\n\n\n[C]\n Understands that the properties of hierarchical subsumption within an RDF vocabulary -- rdfs:subPropertyOf and rdfs:subClassOf -- can also be used to express mappings between vocabularies.\n\n\n[C]\n Understands that owl:equivalentProperty and owl:equivalentClass may be used when equivalencies between properties or between classes are exact.\n\n\n[C]\n Recognizes that owl:sameAs, while popular as a mapping property, has strong formal semantics that can entail unintended inferences.\n\n\n\n\n[B]\n RDF application profiles\n\n\n\n\n[C]\n Identifies real-world entities in an application domain as candidates for RDF classes.\n\n\n[C]\n Identifies resource attributes and relationships between domain entities as candidates for RDF properties.\n\n\n[C]\n Investigates how others have modeled the same or similar application domains.\n\n\n[D]\n Communicates a domain model with words and diagrams.\n\n\n[D]\n Participates in the social process of developing application profiles.\n\n\n\n\n\n\n[A]\n Creating and transforming Linked Data\n\n\n[B]\n Managing identifiers (URI)\n\n\n\n\n[C]\n Understands that to be \"persistent\", a URI must have a stable, well-documented meaning and be plausibly intended to identify a given resource in perpetuity.\n\n\n[C]\n Understands trade-offs between \"opaque\" URIs and URIs using version numbers, server names, dates, application-specific file extensions, query strings or other obsoletable context.\n\n\n[C]\n Recognizes the desirability of a published namespace policy describing an institution's commitment to the persistence and semantic stability of important URIs.\n\n\n\n\n[B]\n Creating RDF data\n\n\n\n\n[C]\n Generates RDF data from non-RDF sources.\n\n\n[C]\n Knows methods for generating RDF data from tabular data in formats such as Comma-Separated Values (CSV).\n\n\n[C]\n Knows methods such as Direct Mapping of Relational Data to RDF (2012) for transforming data from the relational model (keys, values, rows, columns, tables) into RDF graphs.\n\n\n\n\n[B]\n Versioning RDF data\n\n\n[B]\n RDF data provenance\n\n\n[B]\n Cleaning and reconciling RDF data\n\n\n\n\n[C]\n Cleans a dataset by finding and correcting errors, removing duplicates and unwanted data.\n\n\n\n\n[B]\n Mapping and enriching RDF data\n\n\n* \n[C]\n Uses available resources for named entity recognition, extraction, and reconciliation.\n\n\n[A]\n Interacting with RDF data\n\n\n[B]\n Finding RDF data\n\n\n\n\n[C]\n Knows relevant resources for discovering existing Linked Data datasets.\n\n\n[C]\n Retrieves and accesses RDF data from the \"open Web\".\n\n\n[C]\n Monitors and updates lists which report the status of SPARQL endpoints.\n\n\n[C]\n Uses available vocabularies for dataset description to support their discovery.\n\n\n[C]\n Registers datasets with relevant services for discovery.\n\n\n\n\n[B]\n Processing RDF data using programming languages.\n\n\n\n\n[C]\n Understands how components of the RDF data model (datasets, graphs, statements, and various types of node) are expressed in the RDF library of a given programming language by constructs such as object-oriented classes.\n\n\n[D]\n Uses an RDF programming library to serialize RDF data in available syntaxes.\n\n\n[D]\n Uses RDF-specific programming methods to iterate over components of RDF data.\n\n\n[D]\n Uses RDF-library-specific convenience representations for common RDF vocabularies such as RDF, Dublin Core, and SKOS.\n\n\n[C]\n Programatically associates namespaces to prefixes for use in serializing RDF or when parsing SPARQL queries.\n\n\n[D]\n Uses RDF programming libraries to extract RDF data from CSV files, databases, or web pages.\n\n\n[D]\n Uses RDF programming libraries to persistently stores triples in memory, on disk, or to interact with triple stores.\n\n\n[D]\n Programatically infers triples using custom functions or methods.\n\n\n[C]\n Understands how the pattern matching of SPARQL queries can be expressed using functionally equivalent constructs in RDF programming libraries.\n\n\n[D]\n Uses RDF-specific programming methods to query RDF data and save the results for further processing.\n\n\n[D]\n Uses utilities and convenience functions the provide shortcuts for frequently used patterns, such as matching the multiple label properties used in real data.\n\n\n[D]\n Uses RDF libraries to process various types of SPARQL query result.\n\n\n\n\n[B]\n Querying RDF data\n\n\n\n\n[C]\n Understands that a SPARQL query matches an RDF graph against a pattern of triples with fixed and variable values.\n\n\n[C]\n Understands the basic syntax of a SPARQL query.\n\n\n[D]\n Uses angle brackets for delimiting URIs.\n\n\n[D]\n Uses question marks for indicating variables.\n\n\n[D]\n Uses PREFIX for base URIs.\n\n\n[C]\n Demonstrates a working knowledge of the forms and uses of SPARQL result sets (SELECT, CONSTRUCT, DESCRIBE, and ASK).\n\n\n[D]\n Uses the SELECT clause to identify the variables to appear in a table of query results.\n\n\n[D]\n Uses the WHERE clause to provide the graph pattern to match against the graph data.\n\n\n[D]\n Uses variables in SELECT and WHERE clauses to yield a table of results.\n\n\n[D]\n Uses ASK for a True/False result test for a match to a query pattern.\n\n\n[D]\n Uses DESCRIBE to extract a single graph containing RDF data about resources.\n\n\n[D]\n Uses CONSTRUCT to extract and transform results into a single RDF graph specified by a graph template.\n\n\n[D]\n Uses FROM to formulate queries with URLs and local files.\n\n\n[C]\n Understands how to combine and filter graph patterns using operators such as UNION, OPTIONAL, FILTER, and MINUS.\n\n\n[D]\n Uses UNION to formulate queries with multiple possible graph patterns.\n\n\n[D]\n Uses OPTIONAL to formulate queries to return the values of optional variables when available.\n\n\n[D]\n Uses FILTER to formulates queries that eliminate solutions from a result set.\n\n\n[D]\n Uses NOT EXISTS to limit whether a given graph pattern exists in the data.\n\n\n[D]\n Uses MINUS to remove matches from a result based on the evaluation of two patterns.\n\n\n[D]\n Uses NOT IN to restrict a variable to not being in a given set of values.\n\n\n[C]\n Understands the major SPARQL result set modifiers, e.g., to limit or sort results, or to return distinct results only once.\n\n\n[D]\n Uses ORDER BY to define ordering conditions by variable, function call, or expression.\n\n\n[D]\n Uses DISTINCT to ensure solutions in the sequence are unique.\n\n\n[D]\n Uses OFFSET to control where the solutions processed start in the overall sequence of solutions.\n\n\n[D]\n Uses LIMIT to restrict the number of solutions processed for query results.\n\n\n[D]\n Uses projection to transform a solution sequence into one involving only a subset of the variables.\n\n\n[C]\n Understands the use of SPARQL functions and operators.\n\n\n[D]\n Uses the regular expression (regex()) function for string matching.\n\n\n[D]\n Uses aggregates to apply expressions over groups of solutions (GROUP BY, COUNT, SUM, AVG, MIN) for partitioning results, evaluating projections, and filtering.\n\n\n[D]\n Uses the lang() function to return the language tag of an RDF literal.\n\n\n[D]\n Uses the langMatches() function to match a language tag against a language range.\n\n\n[D]\n Uses the xsd:decimal(expn) function to convert an expression to an integer.\n\n\n[D]\n Uses the GROUP BY clause to transforms a result set so that only one row will appear for each unique set of grouping variables.\n\n\n[D]\n Uses the HAVING clause to apply a filter to the result set after grouping.\n\n\n[C]\n Differentiates between a Default Graph and a Named Graph, and formulates queries using the GRAPH clause.\n\n\n[D]\n Formulates advanced queries using FROM NAMED and GRAPH on local data.\n\n\n[D]\n Formulates advanced queries using FROM NAMED on remote data.\n\n\n[D]\n Formulates advanced queries on data containing blank nodes.\n\n\n[D]\n Formulates advanced queries using subqueries.\n\n\n[C]\n Uses a temporary variable to extend a query.\n\n\n[C]\n Understands the role of Property Paths and how they are formed by combining predicates with regular expression-like operators.\n\n\n[C]\n Understands the concept of Federated Searches.\n\n\n[D]\n Formulates advanced queries on a remote SPARQL endpoint using the SERVICE directive.\n\n\n[D]\n Uses federated query to query over a local graph store and one or more other SPARQL endpoints.\n\n\n[D]\n Pulls data from a different SPARQL endpoints in one single query using the SERVICE directive.\n\n\n[C]\n Converts/manipulates SPARQL query outputs (RDF-XML, JSON) to the exact format required by a third party tools and APIs.\n\n\n[C]\n Reads and understands high-level descriptions of the classes and properties of a dataset in order to write queries.\n\n\n[C]\n Uses available tools, servers, and endpoints to issue queries against a dataset.\n\n\n[D]\n Execute SPARQL queries using the Jena ARQ command-line utility.\n\n\n[D]\n Queries multiple local data files using ARQ.\n\n\n[D]\n Uses ARQ to evaluate queries on local data.\n\n\n[D]\n Uses Fuseki server to evaluate queries on a dataset.\n\n\n[D]\n Queries multiple data files using Fuseki.\n\n\n[D]\n Accesses DBPedia's SNORQL/SPARQL endpoint and issues simple queries.\n\n\n\n\n[B]\n Visualizing RDF data\n\n\n\n\n[C]\n Uses publicly available tools to visualize data.\n\n\n[D]\n Uses Google FusionTables to create maps and charts.\n\n\n[C]\n Distills results taken from large datasets so that visualizations are human-friendly.\n\n\n[C]\n Converts/manipulates SPARQL query outputs (RDF-XML, JSON) to the exact format required by third party tools and APIs.\n\n\n\n\n[B]\n Reasoning over RDF data\n\n\n\n\n[C]\n Understands the principles and practice of inferencing.\n\n\n[C]\n Uses common entailment regimes and understands their uses.\n\n\n[C]\n Understands the role of formally declared domains and ranges for inferencing.\n\n\n[C]\n Understands how reasoning can be used for integrating diverse datasets.\n\n\n[C]\n Knows that Web Ontology Language (OWL) is available in multiple \"flavors\" that are variously optimized for expressivity, performant reasoning, or for applications involving databases or business rules.\n\n\n[C]\n Understands that OWL Full supports all available constructs and is most appropriately used when reasoning performance is not a concern.\n\n\n\n\n[B]\n Assessing RDF data quality\n\n\n[B]\n RDF data analytics\n\n\n\n\n[C]\n Uses available ontology browsing tools to explore the ontologies used in a particular dataset.\n\n\n\n\n[B]\n Manipulating RDF data\n\n\n\n\n[C]\n Knows the SPARQL 1.1 Update language for updating, creating, and removing RDF graphs in a Graph Store\n\n\n[D]\n Uses INSERT/DELETE to update triples.\n\n\n[D]\n Uses a CONSTRUCT query to preview changes before executing an INSERT/DELETE operation.\n\n\n[C]\n Knows the SPARQL 1.1 Graph Store HTTP protocol for updating graphs on a web server (in \"restful\" style).\n\n\n[D]\n Uses GET to retrieve triples from a default graph or a named graph.\n\n\n[D]\n Uses PUT to insert set of triples into a new graph (or replace an existing graph).\n\n\n[D]\n Uses DELETE to remove a graph.\n\n\n[D]\n Uses POST to add triples to an existing graph.\n\n\n[D]\n Uses proper syntax to request specific media types, such as Turtle.\n\n\n[C]\n Understands the difference between SQL query language (which operates on database tables) and SPARQL (which operates on RDF graphs).\n\n\n\n\n\n\n[A]\n Creating Linked Data applications\n\n\n[B]\n Storing RDF data",
            "title": "CI"
        },
        {
            "location": "/D2695955/#ld4pe-competency-index",
            "text": "Version: 2017-06-22 15:43:48  \nRaw file: https://github.com...  \nView at: https://ld4pe.github.com...",
            "title": "LD4PE Competency Index"
        },
        {
            "location": "/D2695955/#a-topic-cluster",
            "text": "",
            "title": "[A] Topic Cluster"
        },
        {
            "location": "/D2695955/#b-topic",
            "text": "[C] Competency: Tweet-length assertion of knowledge, skill, or habit of mind.  [D] Benchmark: Action demonstrating accomplishment in related competencies.",
            "title": "[B] Topic"
        },
        {
            "location": "/D2695955/#a-fundamentals-of-resource-description-framework",
            "text": "",
            "title": "[A] Fundamentals of Resource Description Framework"
        },
        {
            "location": "/D2695955/#b-identity-in-rdf",
            "text": "[C]  Knows that anything can be named with Uniform Resource Identifiers (URIs), such as agents, places, events, artifacts, and concepts.  [C]  Understands that a \"real-world\" thing may need to be named with a URI distinct from the URI for information about that thing.  [C]  Recognizes that URIs are \"owned\" by the owners of their respective Internet domains.  [C]  Knows that Uniform Resource Identifiers, or URIs (1994), include Uniform Resource Locators (URLs, which locate web pages) as well as location-independent identifiers for physical, conceptual, or web resources.",
            "title": "[B] Identity in RDF"
        },
        {
            "location": "/D2695955/#b-rdf-data-model",
            "text": "[C]  Knows the subject-predicate-object component structure of a triple.  [C]  Understands the difference between literals and non-literal resources.  [C]  Understands that URIs and literals denote things in the world (\"resources\") real, imagined, or conceptual.  [C]  Understands that resources are declared to be members (instances) of classes using the property rdf:type.  [C]  Understands the use of datatypes and language tags with literals.  [C]  Understands blank nodes and their uses.  [C]  Understands that QNames define shorthand prefixes for long URIs.  [D]  Uses prefixes for URIs in RDF specifications and data.  [C]  Articulates differences between the RDF abstract data model and the XML and relational models.  [C]  Understands the RDF abstract data model as a directed labeled graph.  [C]  Knows graphic conventions for depicting RDF-based models.  [D]  Can use graphing or modeling software to share those models with others.  [C]  Understands a named graph as one of the collection of graphs comprising an RDF dataset, with a graph name unique in the context of that dataset.  [C]  Understands how a namespace, informally used in the RDF context for a namespace URI or RDF vocabulary, fundamentally differs from the namespace of data attributes and functions (methods) defined for an object-oriented class.",
            "title": "[B] RDF data model"
        },
        {
            "location": "/D2695955/#b-related-data-models",
            "text": "[C]  Grasps essential differences between schemas for syntactic validation (e.g., XML) and for inferencing (RDF Schema).  [C]  Differentiates hierarchical document models (eg, XML) and graph models (RDF).  [C]  Understands how an RDF class (named set of things) fundamentally differs from an object-oriented programming class, which defines a type of object bundling \"state\" (attributes with data values) and \"behavior\" (functions that operate on state).",
            "title": "[B] Related data models"
        },
        {
            "location": "/D2695955/#b-rdf-serialization",
            "text": "[C]  Understands RDF serializations as interchangeable encodings of a given set of triples (RDF graph).  [D]  Uses tools to convert RDF data between different serializations.  [C]  Distinguishes the RDF abstract data model and concrete serializations of RDF data.  [D]  Expresses data in serializations such as RDF/XML, N-Triples, Turtle, N3, Trig, JSON-LD, and RDFa.",
            "title": "[B] RDF serialization"
        },
        {
            "location": "/D2695955/#a-fundamentals-of-linked-data",
            "text": "",
            "title": "[A] Fundamentals of Linked Data"
        },
        {
            "location": "/D2695955/#b-web-technology",
            "text": "[C]  Knows the origins of the World Wide Web (1989) as a non-linear interactive system, or hypermedia, built on the Internet.  [C]  Understands that Linked Data (2006) extended the notion of a web of documents (the Web) to a notion of a web of finer-grained data (the Linked Data cloud).  [C]  Knows HyperText Markup Language, or HTML (1991+), as a language for \"marking up\" the content and multimedia components of Web pages.  [C]  Knows HTML5 (2014) as a version of HTML extended with support for complex web and mobile applications.  [C]  Knows Hypertext Transfer Protocol, or HTTP (1991+), as the basic technology for resolving hyperlinks and transferring data on the World Wide Web.  [C]  Knows Representational State Transfer, or REST (2000) as a software architectural style whereby browsers can exchange data with web servers, typically on the basis of well-known HTTP actions.",
            "title": "[B] Web technology"
        },
        {
            "location": "/D2695955/#b-linked-data-principles",
            "text": "[C]  Knows Tim Berners-Lee's principles of Linked Data: use URIs to name things, use HTTP URIs that can be resolved to useful information, and create links to URIs of other things.  [C]  Knows the \"five stars\" of Open Data: put data on the Web, preferably in a structured and preferably non-proprietary format, using URIs to name things, and link to other data.",
            "title": "[B] Linked Data principles"
        },
        {
            "location": "/D2695955/#b-linked-data-policies-and-best-practices",
            "text": "[C]  Knows the primary organizations related to Linked Data standardization.  [D]  Participates in developing standards and best practice with relevant organizations such as W3C.",
            "title": "[B] Linked Data policies and best practices"
        },
        {
            "location": "/D2695955/#b-non-rdf-linked-data",
            "text": "",
            "title": "[B] Non-RDF linked data"
        },
        {
            "location": "/D2695955/#a-rdf-vocabularies-and-application-profiles",
            "text": "",
            "title": "[A] RDF vocabularies and application profiles"
        },
        {
            "location": "/D2695955/#b-finding-rdf-based-vocabularies",
            "text": "[D]  [MOVE]Knows portals and registries for finding RDF-based vocabularies.  [D]  Finds properties and classes in the Linked Open Vocabularies (LOV) observatory and explores their versions and dependencies.",
            "title": "[B] Finding RDF-based vocabularies"
        },
        {
            "location": "/D2695955/#b-designing-rdf-based-vocabularies",
            "text": "[C]  Uses RDF Schema to express semantic relationships within a vocabulary.  [D]  Correctly uses sub-class relationships in support of inference.  [D]  Correctly uses sub-property relationships in support of inference.  [C]  Reuses published properties and classes where available.  [C]  Coins namespace URIs, as needed, for any new properties and classes required.  [D]  Drafts a policy for coining URIs for properties and classes.  [D]  Chooses \"hash\"- or \"slash\"-based URI patterns based on requirements.  [C]  Knows Web Ontology Language, or OWL (2004), as a RDF vocabulary of properties and classes that extend support for expressive data modeling and automated inferencing (reasoning).  [C]  Knows that the word \"ontology\" is ambiguous, referring to any RDF vocabulary, but more typically a set of OWL classes and properties designed to support inferencing in a specific domain.  [C]  Knows Simple Knowledge Organization System, or SKOS (2009), an RDF vocabulary for expressing concepts that are labeled in natural languages, organized into informal hierarchies, and aggregated into concept schemes.  [C]  Knows SKOS eXtension for Labels, or SKOS-XL (2009), a small set of additional properties for describing and linking lexical labels as instances of the class Label.  [C]  Understands that in a formal sense, a SKOS concept is not an RDF class but an instance and, as such, is not formally associated with a set of instances (\"class extension\").  [C]  Understands that SKOS can express a flexibly associative structure of concepts without enabling the more rigid and automatic inferences typically specified in a class-based OWL ontology.  [C]  Understands that in contrast to OWL sub-class chains, hierarchies of SKOS concepts are designed not to form transitive chains automatically because this is not how humans think or organize information.  [C]  Knows the naming conventions for RDF properties and classes.",
            "title": "[B] Designing RDF-based vocabularies"
        },
        {
            "location": "/D2695955/#b-maintaining-rdf-vocabularies",
            "text": "[C]  Understands policy options for persistence guarantees.  [D]  Can draft a persistence policy.",
            "title": "[B] Maintaining RDF vocabularies"
        },
        {
            "location": "/D2695955/#b-versioning-rdf-vocabularies",
            "text": "[C]  Knows technical options for the form, content, and granularity of versions.  [C]  Understands the trade-offs between publishing RDF vocabularies in periodic, numbered releases versus more continual or incremental approaches.  [D]  Can express and justify a versioning policy.",
            "title": "[B] Versioning RDF vocabularies"
        },
        {
            "location": "/D2695955/#b-publishing-rdf-vocabularies",
            "text": "[C]  Understands the typical publication formats for RDF vocabularies and their relative advantages  [C]  Understands the purpose of publishing RDF vocabularies in multiple formats using content negotiation.  [C]  Understands that to be \"dereferencable\", a URI should be usable to retrieve a representation of the resource it identifies.  [D]  Ensures that when dereferenced by a Web browser, a URI returns a representation of the resource in human-readable HTML.  [D]  Ensures that when dereferenced by an RDF application, a URI returns representation of the resource in the requested RDF serialization syntax.",
            "title": "[B] Publishing RDF vocabularies"
        },
        {
            "location": "/D2695955/#b-mapping-rdf-vocabularies",
            "text": "[C]  Understands that the properties of hierarchical subsumption within an RDF vocabulary -- rdfs:subPropertyOf and rdfs:subClassOf -- can also be used to express mappings between vocabularies.  [C]  Understands that owl:equivalentProperty and owl:equivalentClass may be used when equivalencies between properties or between classes are exact.  [C]  Recognizes that owl:sameAs, while popular as a mapping property, has strong formal semantics that can entail unintended inferences.",
            "title": "[B] Mapping RDF vocabularies"
        },
        {
            "location": "/D2695955/#b-rdf-application-profiles",
            "text": "[C]  Identifies real-world entities in an application domain as candidates for RDF classes.  [C]  Identifies resource attributes and relationships between domain entities as candidates for RDF properties.  [C]  Investigates how others have modeled the same or similar application domains.  [D]  Communicates a domain model with words and diagrams.  [D]  Participates in the social process of developing application profiles.",
            "title": "[B] RDF application profiles"
        },
        {
            "location": "/D2695955/#a-creating-and-transforming-linked-data",
            "text": "",
            "title": "[A] Creating and transforming Linked Data"
        },
        {
            "location": "/D2695955/#b-managing-identifiers-uri",
            "text": "[C]  Understands that to be \"persistent\", a URI must have a stable, well-documented meaning and be plausibly intended to identify a given resource in perpetuity.  [C]  Understands trade-offs between \"opaque\" URIs and URIs using version numbers, server names, dates, application-specific file extensions, query strings or other obsoletable context.  [C]  Recognizes the desirability of a published namespace policy describing an institution's commitment to the persistence and semantic stability of important URIs.",
            "title": "[B] Managing identifiers (URI)"
        },
        {
            "location": "/D2695955/#b-creating-rdf-data",
            "text": "[C]  Generates RDF data from non-RDF sources.  [C]  Knows methods for generating RDF data from tabular data in formats such as Comma-Separated Values (CSV).  [C]  Knows methods such as Direct Mapping of Relational Data to RDF (2012) for transforming data from the relational model (keys, values, rows, columns, tables) into RDF graphs.",
            "title": "[B] Creating RDF data"
        },
        {
            "location": "/D2695955/#b-versioning-rdf-data",
            "text": "",
            "title": "[B] Versioning RDF data"
        },
        {
            "location": "/D2695955/#b-rdf-data-provenance",
            "text": "",
            "title": "[B] RDF data provenance"
        },
        {
            "location": "/D2695955/#b-cleaning-and-reconciling-rdf-data",
            "text": "[C]  Cleans a dataset by finding and correcting errors, removing duplicates and unwanted data.",
            "title": "[B] Cleaning and reconciling RDF data"
        },
        {
            "location": "/D2695955/#b-mapping-and-enriching-rdf-data",
            "text": "",
            "title": "[B] Mapping and enriching RDF data"
        },
        {
            "location": "/D2695955/#c-uses-available-resources-for-named-entity-recognition-extraction-and-reconciliation",
            "text": "",
            "title": "* [C] Uses available resources for named entity recognition, extraction, and reconciliation."
        },
        {
            "location": "/D2695955/#a-interacting-with-rdf-data",
            "text": "",
            "title": "[A] Interacting with RDF data"
        },
        {
            "location": "/D2695955/#b-finding-rdf-data",
            "text": "[C]  Knows relevant resources for discovering existing Linked Data datasets.  [C]  Retrieves and accesses RDF data from the \"open Web\".  [C]  Monitors and updates lists which report the status of SPARQL endpoints.  [C]  Uses available vocabularies for dataset description to support their discovery.  [C]  Registers datasets with relevant services for discovery.",
            "title": "[B] Finding RDF data"
        },
        {
            "location": "/D2695955/#b-processing-rdf-data-using-programming-languages",
            "text": "[C]  Understands how components of the RDF data model (datasets, graphs, statements, and various types of node) are expressed in the RDF library of a given programming language by constructs such as object-oriented classes.  [D]  Uses an RDF programming library to serialize RDF data in available syntaxes.  [D]  Uses RDF-specific programming methods to iterate over components of RDF data.  [D]  Uses RDF-library-specific convenience representations for common RDF vocabularies such as RDF, Dublin Core, and SKOS.  [C]  Programatically associates namespaces to prefixes for use in serializing RDF or when parsing SPARQL queries.  [D]  Uses RDF programming libraries to extract RDF data from CSV files, databases, or web pages.  [D]  Uses RDF programming libraries to persistently stores triples in memory, on disk, or to interact with triple stores.  [D]  Programatically infers triples using custom functions or methods.  [C]  Understands how the pattern matching of SPARQL queries can be expressed using functionally equivalent constructs in RDF programming libraries.  [D]  Uses RDF-specific programming methods to query RDF data and save the results for further processing.  [D]  Uses utilities and convenience functions the provide shortcuts for frequently used patterns, such as matching the multiple label properties used in real data.  [D]  Uses RDF libraries to process various types of SPARQL query result.",
            "title": "[B] Processing RDF data using programming languages."
        },
        {
            "location": "/D2695955/#b-querying-rdf-data",
            "text": "[C]  Understands that a SPARQL query matches an RDF graph against a pattern of triples with fixed and variable values.  [C]  Understands the basic syntax of a SPARQL query.  [D]  Uses angle brackets for delimiting URIs.  [D]  Uses question marks for indicating variables.  [D]  Uses PREFIX for base URIs.  [C]  Demonstrates a working knowledge of the forms and uses of SPARQL result sets (SELECT, CONSTRUCT, DESCRIBE, and ASK).  [D]  Uses the SELECT clause to identify the variables to appear in a table of query results.  [D]  Uses the WHERE clause to provide the graph pattern to match against the graph data.  [D]  Uses variables in SELECT and WHERE clauses to yield a table of results.  [D]  Uses ASK for a True/False result test for a match to a query pattern.  [D]  Uses DESCRIBE to extract a single graph containing RDF data about resources.  [D]  Uses CONSTRUCT to extract and transform results into a single RDF graph specified by a graph template.  [D]  Uses FROM to formulate queries with URLs and local files.  [C]  Understands how to combine and filter graph patterns using operators such as UNION, OPTIONAL, FILTER, and MINUS.  [D]  Uses UNION to formulate queries with multiple possible graph patterns.  [D]  Uses OPTIONAL to formulate queries to return the values of optional variables when available.  [D]  Uses FILTER to formulates queries that eliminate solutions from a result set.  [D]  Uses NOT EXISTS to limit whether a given graph pattern exists in the data.  [D]  Uses MINUS to remove matches from a result based on the evaluation of two patterns.  [D]  Uses NOT IN to restrict a variable to not being in a given set of values.  [C]  Understands the major SPARQL result set modifiers, e.g., to limit or sort results, or to return distinct results only once.  [D]  Uses ORDER BY to define ordering conditions by variable, function call, or expression.  [D]  Uses DISTINCT to ensure solutions in the sequence are unique.  [D]  Uses OFFSET to control where the solutions processed start in the overall sequence of solutions.  [D]  Uses LIMIT to restrict the number of solutions processed for query results.  [D]  Uses projection to transform a solution sequence into one involving only a subset of the variables.  [C]  Understands the use of SPARQL functions and operators.  [D]  Uses the regular expression (regex()) function for string matching.  [D]  Uses aggregates to apply expressions over groups of solutions (GROUP BY, COUNT, SUM, AVG, MIN) for partitioning results, evaluating projections, and filtering.  [D]  Uses the lang() function to return the language tag of an RDF literal.  [D]  Uses the langMatches() function to match a language tag against a language range.  [D]  Uses the xsd:decimal(expn) function to convert an expression to an integer.  [D]  Uses the GROUP BY clause to transforms a result set so that only one row will appear for each unique set of grouping variables.  [D]  Uses the HAVING clause to apply a filter to the result set after grouping.  [C]  Differentiates between a Default Graph and a Named Graph, and formulates queries using the GRAPH clause.  [D]  Formulates advanced queries using FROM NAMED and GRAPH on local data.  [D]  Formulates advanced queries using FROM NAMED on remote data.  [D]  Formulates advanced queries on data containing blank nodes.  [D]  Formulates advanced queries using subqueries.  [C]  Uses a temporary variable to extend a query.  [C]  Understands the role of Property Paths and how they are formed by combining predicates with regular expression-like operators.  [C]  Understands the concept of Federated Searches.  [D]  Formulates advanced queries on a remote SPARQL endpoint using the SERVICE directive.  [D]  Uses federated query to query over a local graph store and one or more other SPARQL endpoints.  [D]  Pulls data from a different SPARQL endpoints in one single query using the SERVICE directive.  [C]  Converts/manipulates SPARQL query outputs (RDF-XML, JSON) to the exact format required by a third party tools and APIs.  [C]  Reads and understands high-level descriptions of the classes and properties of a dataset in order to write queries.  [C]  Uses available tools, servers, and endpoints to issue queries against a dataset.  [D]  Execute SPARQL queries using the Jena ARQ command-line utility.  [D]  Queries multiple local data files using ARQ.  [D]  Uses ARQ to evaluate queries on local data.  [D]  Uses Fuseki server to evaluate queries on a dataset.  [D]  Queries multiple data files using Fuseki.  [D]  Accesses DBPedia's SNORQL/SPARQL endpoint and issues simple queries.",
            "title": "[B] Querying RDF data"
        },
        {
            "location": "/D2695955/#b-visualizing-rdf-data",
            "text": "[C]  Uses publicly available tools to visualize data.  [D]  Uses Google FusionTables to create maps and charts.  [C]  Distills results taken from large datasets so that visualizations are human-friendly.  [C]  Converts/manipulates SPARQL query outputs (RDF-XML, JSON) to the exact format required by third party tools and APIs.",
            "title": "[B] Visualizing RDF data"
        },
        {
            "location": "/D2695955/#b-reasoning-over-rdf-data",
            "text": "[C]  Understands the principles and practice of inferencing.  [C]  Uses common entailment regimes and understands their uses.  [C]  Understands the role of formally declared domains and ranges for inferencing.  [C]  Understands how reasoning can be used for integrating diverse datasets.  [C]  Knows that Web Ontology Language (OWL) is available in multiple \"flavors\" that are variously optimized for expressivity, performant reasoning, or for applications involving databases or business rules.  [C]  Understands that OWL Full supports all available constructs and is most appropriately used when reasoning performance is not a concern.",
            "title": "[B] Reasoning over RDF data"
        },
        {
            "location": "/D2695955/#b-assessing-rdf-data-quality",
            "text": "",
            "title": "[B] Assessing RDF data quality"
        },
        {
            "location": "/D2695955/#b-rdf-data-analytics",
            "text": "[C]  Uses available ontology browsing tools to explore the ontologies used in a particular dataset.",
            "title": "[B] RDF data analytics"
        },
        {
            "location": "/D2695955/#b-manipulating-rdf-data",
            "text": "[C]  Knows the SPARQL 1.1 Update language for updating, creating, and removing RDF graphs in a Graph Store  [D]  Uses INSERT/DELETE to update triples.  [D]  Uses a CONSTRUCT query to preview changes before executing an INSERT/DELETE operation.  [C]  Knows the SPARQL 1.1 Graph Store HTTP protocol for updating graphs on a web server (in \"restful\" style).  [D]  Uses GET to retrieve triples from a default graph or a named graph.  [D]  Uses PUT to insert set of triples into a new graph (or replace an existing graph).  [D]  Uses DELETE to remove a graph.  [D]  Uses POST to add triples to an existing graph.  [D]  Uses proper syntax to request specific media types, such as Turtle.  [C]  Understands the difference between SQL query language (which operates on database tables) and SPARQL (which operates on RDF graphs).",
            "title": "[B] Manipulating RDF data"
        },
        {
            "location": "/D2695955/#a-creating-linked-data-applications",
            "text": "",
            "title": "[A] Creating Linked Data applications"
        },
        {
            "location": "/D2695955/#b-storing-rdf-data",
            "text": "",
            "title": "[B] Storing RDF data"
        }
    ]
}